# Day 10 Explanation

## Part 1
My part 1 solution uses the simple rule that steps of length 1 should be prioritized over steps of length 3.  This makes sense, because the solution requires that every adapter be used once.  To make this simple I started by sorting the list, which makes looping over the input in ascending order simple.  Then it's just a matter of counting the number of steps of length 1 and 3 and multiplying the counts together.

## Part 2 
Part 2 was a more interesting problem, and requires a knowledge of dynamic programming algorithms to solve.  My first attempt at a solution actually used a recursive method that would take sub-lists and find the solution for that list.  This method is found in inital_attempt_2.py.  The basic principle was that for each spot in the sorted input list, check if there is a possible solution by reaching any of the next 3 adapters (3, because if each adapter has a unique joltage, the farthest any jump could be is 3 places.)  If it is possible to make the jump, recursively call the method on the list from that position onwards.  As a base case, if the function receives a list of size 1 as input (the last element in the list), return 1 for the last possible jump.  Aggregate the recursive calls into a single sum and that would be the solution.  This solution worked like a charm for the smaller test data sets, but due to the recursive nature it would end up running way, way too long on the larger input.  In fact, because every time the recursive function is called it calls itself (usually) 3 more times, this function has a complexity of <code>O(3<sup>n</sup>)</code>, way too complex for long inputs.

So, I had to find a new solution.  My next, and ultimately final attempt uses **dynamic programming**.  Dynamic programming is a method of optimizing recursion, by storing the solutions to subproblems for quick access later, thereby removing repeated calculations of the same values.  In my initial recursion strategy above, using the larger test data set of 31 elements I would end up recalculating the same values over and over again, increasing manifold by the time I reach the end of the list.  The first and second values would only be calculated once, but the 31st value would be separately recalculated **19,208 times**.

That's not so bad for a list of only 31 elements.  After all, that final calculation is always 1, and gets calculated quickly.  But for a list twice that size, where the number of recalculations is increasing exponentially, such calculations quickly become impossible.  That's where dynamic programming comes in.  Instead of recalculating, let's find a solution where we calculate each position once, then refer back to that calculation when we need it to solve the larger problem.  To do this, I initialize an array called `dp` that stores the calculated solution at each step (note that for this to work, both the starting value of 0, representing the outlet, and the final value of `max(input_file)+3` need to be included in the list).  Then, because we know that there is only one connection from the outlet to an adapter that will work, we can start by saying that `dp[0] = 1`.  Now, looping through the remaining inputs, we can start to work backwards.  We know that, given any element, if any of the previous elements are able to connect to this one (they have a value of 3 or less), there are as many possible connections as that previous element has, plus any other connections we can make.  In other words, each adapter adds new possible connections, equal to the sum of however many possible connections the previous adapters that can connect to the current adapter could make.

For example, consider the following 5 elements:  `[0, 1, 2, 3, 4]`.  The first element we know can make 1 possible connection:  0 -> 1.  Now move on to the second element (1).  This element only has one possible connection, to the first element (0).  Therefore, there's still only one possible configuration.  We store this in the dynamic programming array:  `dp = [1, 1]`.  Now the 3rd element:  this element can connect to either 0 or 1, because both are within 3 of the current element.  Therefore, we know that from this point on there are two possible configurations, the sum of the possible configurations of the two adapters it can connect to.  `dp = [1, 1, 2]`.  The next element is 3.  3 can connect to any of the previous elements, because all are within 3 of it.  Therefore, we sum these three dp elements:  `dp = [1, 1, 2, 4]`.  4 can connect to 1, 2, or 3, but not to zero, so we sum all but the first element in the dp array:  `dp = [1, 1, 2, 4, 7]`.  Because 4 is the final connection in this sample, our solution is 7.

Using this method, all positions and possible connections are calculated only once, as opposed to tens of thousands of times under the original recursive strategy.  This saves the program an exponential amount of calculation time, calculating a solution in <code>O(n<sup>2</sup>)</code> time.  